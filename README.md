# go-utils

`go-utils` — это библиотека утилит для языка программирования Go. Предоставляет удобные обобщённые функции и
инструменты для работы со срезами, строками, временем и многим другим.

## Пакеты

- [generics](#generics)
- [maps](#maps)
- [math](#math)
- [models](#models)
- [other](#other)
- [slices](#slices)
- [strings](#strings)
- [time](#time)

## generics

Пакет предоставляющий общие типы для использования в других пакетах проекта. Позволяет обобщить функции и
типы данных, чтобы работать с различными типами значений.

### Основные типы:

- **[Numeric](#Numeric)** - объединяет все числовые типы, такие как `int`, `float32`, `uint` и другие.

#### Numeric

Интерфейс `Numeric` объединяет все числовые типы, такие как `int`, `float32`, `uint` и другие.

##### Пример использования:

```go
func Sum[T Numeric](n []T) T {
    var sum T
    for _, v := range n {
		sum += v
	}
	return sum
}

```

## maps

Пакет предоставляющий функции для удобной работы с картами (map).

### Основные функции:

- **[Has](#Has)**: Проверяет, содержит ли карта данный ключ.
- **[Merge](#Merge)**: Объединяет две карты. Значения из карты "a" имеют более высокий приоритет.
- **[DiffKeys](#DiffKeys)**: Возвращает карту "a" без элементов из карты "b".

#### Has

Проверяет, содержит ли карта данный ключ.

**Параметры:**

- `m` — карта типа `map[K]V`, где `K` — ключи, а `V` — значения.
- `n` — ключ, который необходимо проверить.

**Возвращаемое значение:**

- `bool` — `true`, если ключ присутствует в карте, иначе `false`.

##### Пример использования:

```go
m := map[string]int{"one": 1, "two": 2}
exists := maps.Has(m, "two")
// exists: true
```

#### Merge

Объединяет две карты. Значения из карты "a" имеют более высокий приоритет.

**Параметры:**

- `a` — первая карта типа `map[K]V`.
- `b` — вторая карта типа `map[K]V`.

**Возвращаемое значение:**

- `map[K]V` — новая карта, содержащая объединенные элементы.

##### Пример использования:

```go
a := map[string]int{"one": 1, "two": 2}
b := map[string]int{"two": 3, "three": 4}
merged := maps.Merge(a, b)
// merged: {"one": 1, "two": 3, "three": 4}
```

#### DiffKeys

Возвращает карту "a" без элементов из карты "b".

**Параметры:**

- `a` — карта типа `map[K]V`, из которой будут удалены элементы.
- `b` — карта типа `map[K]V`, содержащая ключи, которые нужно удалить из карты "a".

**Возвращаемое значение:**

- `map[K]V` — новая карта, содержащая элементы из "a", которых нет в "b".

##### Пример использования:

```go
a := map[string]int{"one": 1, "two": 2, "three": 3}
b := map[string]int{"two": 2, "four": 4}
diff := maps.DiffKeys(a, b)
// diff: {"one": 1, "three": 3}
```

## math

Пакет предоставляющий математические функции для работы с числовыми типами.

### Основные функции:

- **[Max](#Max)**: Возвращает максимальное значение из переданных аргументов.
- **[Min](#Min)**: Возвращает минимальное значение из переданных аргументов.
- **[Sum](#Sum)**: Возвращает сумму всех переданных значений.

#### Max

Возвращает максимальное значение из переданных аргументов.

**Параметры:**

- `n` — переменное количество аргументов типа `T`, где `T` — любой числовой тип, поддерживаемый интерфейсом `Numeric`.

**Возвращаемое значение:**

- `T` — максимальное значение из переданных аргументов.

##### Пример использования:

```go
maxValue := math.Max(1, 2, 3, 4, 5)
// maxValue: 5
```

#### Min

Возвращает минимальное значение из переданных аргументов.

**Параметры:**

- `n` — переменное количество аргументов типа `T`, где `T` — любой числовой тип, поддерживаемый интерфейсом `Numeric`.

**Возвращаемое значение:**

- `T` — минимальное значение из переданных аргументов.

##### Пример использования:

```go
minValue := math.Min(1, 2, 3, 4, 5)
// minValue: 1
```

#### Sum

Возвращает сумму всех переданных значений.

**Параметры:**

- `n` — переменное количество аргументов типа `T`, где `T` — любой числовой тип, поддерживаемый интерфейсом `Numeric`.

**Возвращаемое значение:**

- `T` — сумма всех переданных аргументов.

##### Пример использования:

```go
total := math.Sum(1, 2, 3, 4, 5)
// total: 15
```

## models

Пакет предоставляющий функции для работы с сущностями (моделями).

### Основные функции:

- **[CollectIDs](#CollectIDs)**: Возвращает срез идентификаторов из среза сущностей.
- **[CollectIDsFromMap](#CollectIDsFromMap)**: Возвращает срез идентификаторов из карты сущностей.
- **[UniqueValues](#UniqueValues)**: Метод для сборки уникальных значений из любого поля модели в срез с желаемым типом
  результата.
- **[UniqueValuesFromMap](#UniqueValuesFromMap)**: Метод для сборки уникальных значений из любого поля модели в срез с
  желаемым типом результата, используя карту.

#### CollectIDs

Возвращает срез идентификаторов из среза сущностей`.

**Параметры:**

- `sl` — срез сущностей типа `T`, которые имеют id.

**Возвращаемое значение:**

- `[]uint` — срез уникальных идентификаторов.

##### Пример использования:

```go
type User struct {
    ID uint 
	// другие поля
}

func (u User) GetID() uint {
    return u.ID
}

users := []User{{ID: 1}, {ID: 2}, {ID: 1}}
ids := CollectIDs(users)
// ids: []uint{1, 2}
```

#### CollectIDsFromMap

Возвращает срез идентификаторов из карты сущностей, которые имеют id.

**Параметры:**

- `m` — карта, где ключи имеют тип `K`, а значения типа `T`, которые имеют id.

**Возвращаемое значение:**

- `[]uint` — срез уникальных идентификаторов.

##### Пример использования:

```go
type User struct {
ID uint
// другие поля
}

func (u User) GetID() uint {
    return u.ID
}

userMap := map[string]User{
    "user1": {ID: 1},
    "user2": {ID: 2},
    "user3": {ID: 1},
}

ids := CollectIDsFromMap(userMap)
// ids: []uint{1, 2}
```

#### UniqueValues

Метод для сборки уникальных значений из любого поля модели в срез с желаемым типом результата.

**Параметры:**

- `slice` — срез сущностей типа `S`.
- `getter` — функция, принимающая сущность типа `S` и возвращающая значение типа `R`, которое будет добавлено в итоговый
  срез.

**Возвращаемое значение:**

- `[]R` — срез уникальных значений, полученных из переданного среза.

##### Пример использования:

```go
type Product struct {
ID   uint
Name string
}

func GetProductID(p Product) uint {
    return p.ID
}

products := []Product{
    {ID: 1, Name: "Product A"},
    {ID: 2, Name: "Product B"},
    {ID: 1, Name: "Product C"},
}

uniqueIDs := UniqueValues(products, GetProductID)
// uniqueIDs: []uint{1, 2}
```

#### UniqueValuesFromMap

Метод для сборки уникальных значений из любого поля модели в срез с желаемым типом результата, используя карту.

**Параметры:**

- `m` — карта, где ключи имеют тип `K`, а значения имеют тип `V`.
- `getter` — функция, принимающая значение типа `V` и возвращающая значение типа `R`, которое будет добавлено в итоговый
  срез.

**Возвращаемое значение:**

- `[]R` — срез уникальных значений, полученных из переданной карты.

##### Пример использования:

```go
type User struct {
    ID   uint
    Name string
}

func GetUserName(u User) string {
    return u.Name
}

users := map[string]User{
    "user1": {ID: 1, Name: "Alice"},
    "user2": {ID: 2, Name: "Bob"},
    "user3": {ID: 3, Name: "Alice"},
}

uniqueNames := UniqueValuesFromMap(users, GetUserName)
// uniqueNames: []string{"Alice", "Bob"}
```

## other

Пакет, который содержит вспомогательные функции для работы с различными типами данных.

### Основные функции:

- **[FirstNonEmpty](#FirstNonEmpty)**: Возвращает первый элемент с ненулевым значением из переданных аргументов.

#### FirstNonEmpty

Возвращает первый элемент с ненулевым значением из переданных аргументов.

**Параметры:**

- `tt` — переменное количество аргументов типа `T`, где `T` — любой тип, поддерживающий сравнение.

**Возвращаемое значение:**

- `T` — первый ненулевой элемент из переданных аргументов. Если все элементы равны нулю, возвращает значение по
  умолчанию для типа `T`.

##### Пример использования:

```go
first := other.FirstNonEmpty("", "hello", "world")
// first: "hello"

firstNum := other.FirstNonEmpty(0, 1, 2)
// firstNum: 1

firstNil := other.FirstNonEmpty(nil, nil)
// firstNil: nil
```

## slices

Пакет предоставляющий функции для работы со срезами (slice).

### Основные функции:

- **[ConvertSlice](#ConvertSlice)**: изменяет тип элементов в срезе.
- **[FilterNil](#FilterNil)**: возвращает срез без пустых значений (например, 0, "", и т.д.), модифицируя оригинальный
  срез.
- **[Unique](#Unique)**: возвращает срез без дубликатов, модифицируя оригинальный срез.
- **[Union](#Union)**: объединяет два среза, исключая дубликаты.
- **[Cross](#Cross)**: возвращает срез со значениями, присутствующими в обоих срезах.
- **[IsEqual](#IsEqual)**: проверяет, идентичны ли срезы, независимо от порядка элементов.
- **[Has](#Has)**: проверяет, содержит ли срез данное значение.
- **[TrimStrings](#TrimStrings)**: удаляет пробелы из каждого элемента строкового среза.
- **[ToKeyMap](#ToKeyMap)**: возвращает карту с ключами, равными значениям среза.
- **[SliceDiff](#SliceDiff)**: возвращает срез, содержащий элементы, присутствующие в первом срезе, но отсутствующие в
  остальных.
- **[SliceIntersect](#SliceIntersect)**: возвращает срез с уникальными значениями, присутствующими во всех переданных
  срезах.
- **[Max](#Max)**: возвращает максимальное значение из представленных элементов.
- **[Min](#Min)**: возвращает минимальное значение из представленных элементов.
- **[Sum](#Sum)**: возвращает сумму всех значений.

### ConvertSlice

Функция, которая изменяет тип элементов в срезе.

**Параметры:**

- `s` — срез элементов типа `T`, который необходимо преобразовать.

**Возвращаемое значение:**

- `[]R` — новый срез элементов типа `R`, полученный путем преобразования элементов из среза `s`.

**Пример использования:**

```go
newSlice := slices.ConvertSlice[int32, uint]([]int32{1, 2, 3})
// newSlice: []uint{1, 2, 3}
```

### FilterNil

Функция, которая возвращает срез без пустых значений (например, `0`, `""` и т. д.). Обратите внимание, что
она модифицирует оригинальный срез.

**Параметры:**

- `sl` — срез элементов типа `T`, из которого будут удалены пустые значения.

**Возвращаемое значение:**

- `[]T` — срез, содержащий только непустые значения.

**Пример использования:**

```go
values := []int{0, 1, 2, 0, 3}
filtered := slices.FilterNil(values)
// filtered: []int{1, 2, 3}
```

### Unique

Функция, которая возвращает срез без дубликатов. Обратите внимание, что она модифицирует оригинальный срез.

**Параметры:**

- `sl` — срез элементов типа `T`, из которого будут удалены дубликаты.

**Возвращаемое значение:**

- `[]T` — срез, содержащий только уникальные значения.

**Пример использования:**

```go
values := []int{1, 2, 2, 3, 4, 4}
uniqueValues := slices.Unique(values)
// uniqueValues: []int{1, 2, 3, 4}
```

### Union

Функция, которая объединяет два среза, исключая дубликаты.

**Параметры:**

- `sl1` — первый срез типа `T`.
- `sl2` — второй срез типа `T`.

**Возвращаемое значение:**

- `[]T` — новый срез, содержащий уникальные значения из обоих входных срезов.

**Пример использования:**

```go
slice1 := []int{1, 2, 3}
slice2 := []int{3, 4, 5}
result := slices.Union(slice1, slice2)
// result: []int{1, 2, 3, 4, 5}
```

### Cross

Функция, которая возвращает срез значений, присутствующих в обоих входных срезах.

**Параметры:**

- `sl1` — первый срез типа `T`.
- `sl2` — второй срез типа `T`.

**Возвращаемое значение:**

- `[]T` — новый срез, содержащий значения, которые присутствуют в обоих входных срезах.

**Пример использования:**

```go
slice1 := []int{1, 2, 3}
slice2 := []int{2, 3, 4}
result := slices.Cross(slice1, slice2)
// result: []int{2, 3}
```

### IsEqual

Функция, которая проверяет, идентичны ли два среза, независимо от порядка элементов.

**Параметры:**

- `sl1` — первый срез типа `T`.
- `sl2` — второй срез типа `T`.

**Возвращаемое значение:**

- `bool` — `true`, если срезы идентичны (содержат одинаковые элементы в любом порядке), иначе `false`.

**Пример использования:**

```go
slice1 := []int{1, 2, 3}
slice2 := []int{3, 2, 1}
isEqual := slices.IsEqual(slice1, slice2)
// isEqual: true
```

### Has

Функция, которая проверяет, содержит ли срез заданное значение.

**Параметры:**

- `sl` — срез типа `T`, в котором выполняется поиск.
- `n` — значение типа `T`, которое необходимо найти в срезе.

**Возвращаемое значение:**

- `bool` — `true`, если значение присутствует в срезе, иначе `false`.

**Пример использования:**

```go
slice := []string{"apple", "banana", "cherry"}
exists := slices.Has(slice, "banana")
// exists: true
```

### TrimStrings

Функция, которая обрезает пробелы в начале и конце каждой строки в срезе строк.

**Параметры:**

- `ss` — срез строк, который нужно обработать.

**Возвращаемое значение:**

- `[]string` — срез строк, где каждая строка обрезана от пробелов.

**Пример использования:**

```go
strings := []string{"  apple  ", " banana ", "cherry  "}
trimmed := slices.TrimStrings(strings)
// trimmed: []string{"apple", "banana", "cherry"}
```

### ToKeyMap

Функция, которая преобразует срез значений в карту, где ключами являются элементы среза, а значениями —
булевый тип, указывающий на наличие этих ключей.

**Параметры:**

- `sl` — срез значений типа `T`, который будет преобразован в карту.

**Возвращаемое значение:**

- `map[T]bool` — карта, где ключами являются элементы из среза, а значениями — `true`.

**Пример использования:**

```go
values := []string{"apple", "banana", "cherry"}
keyMap := slices.ToKeyMap(values)
// keyMap: map[string]bool{"apple": true, "banana": true, "cherry": true}
```

### SliceDiff

Функция, которая возвращает срез, содержащий элементы, присутствующие в первом срезе, но отсутствующие в
других переданных срезах.

**Параметры:**

- `slices` — переменное количество срезов типа `T`, из которых будет вычислено различие.

**Возвращаемое значение:**

- `[]T` — срез, содержащий элементы из первого среза, которых нет в остальных.

**Пример использования:**

```go
slice1 := []int{1, 2, 3, 4}
slice2 := []int{3, 4, 5}
slice3 := []int{4, 5, 6}

result := slices.SliceDiff(slice1, slice2, slice3)
// result: []int{1, 2}
```

### SliceIntersect

Функция, которая возвращает срез с уникальными значениями, присутствующими в обоих (или всех)
переданных срезах.

**Параметры:**

- `slices` — переменное количество срезов типа `T`, из которых будет вычислено пересечение.

**Возвращаемое значение:**

- `[]T` — срез, содержащий уникальные элементы, которые присутствуют во всех переданных срезах.

**Пример использования:**

```go
slice1 := []int{1, 2, 3, 4}
slice2 := []int{3, 4, 5}
slice3 := []int{4, 5, 6}

result := slices.SliceIntersect(slice1, slice2, slice3)
// result: []int{4}
```

### Max

Функция, которая возвращает максимальное значение из переданных аргументов.

**Параметры:**

- `n` — переменное количество аргументов типа `T`, где `T` — любой числовой тип, поддерживаемый интерфейсом `Numeric`.

**Возвращаемое значение:**

- `T` — максимальное значение из переданных аргументов.

**Пример использования:**

```go
maxValue := slices.Max([]int{1, 2, 3, 4, 5})
// maxValue: 5
```

### Min

Функция, которая возвращает минимальное значение из переданных аргументов.

**Параметры:**

- `n` — переменное количество аргументов типа `T`, где `T` — любой числовой тип, поддерживаемый интерфейсом `Numeric`.

**Возвращаемое значение:**

- `T` — минимальное значение из переданных аргументов.

**Пример использования:**

```go
minValue := slices.Min([]int{1, 2, 3, 4, 5})
// minValue: 1
```

### Sum

Функция, которая возвращает сумму всех переданных значений.

**Параметры:**

- `n` — переменное количество аргументов типа `T`, где `T` — любой числовой тип, поддерживаемый интерфейсом `Numeric`.

**Возвращаемое значение:**

- `T` — сумма всех переданных аргументов.

**Пример использования:**

```go
total := slices.Sum([]int{1, 2, 3, 4, 5})
// total: 15
```

# strings

Пакет, предоставляющий функции для работы со строками.

### Основные функции:

- **[Truncate](#Truncate)**: Усечет строку до заданного количества рун.

#### Truncate

Усечет строку до заданного количества рун.

**Параметры:**

- `str` — строка, которую необходимо усечь.
- `maxRunes` — максимальное количество рун, до которого строка будет усечена.

**Возвращаемое значение:**

- `string` — усеченная строка, если длина превышает `maxRunes`, иначе оригинальная строка.

##### Пример использования:

```go
result := strings.Truncate("Hello, World!", 5)
// result: "Hello"
```

## time

Пакет, предоставляющий функции для работы с временными значениями.

### Основные функции:

- **[Midnight](#Midnight)**: Возвращает время, соответствующее полуночи для текущей даты в локальном часовом поясе.
- **[MidnightByLocation](#MidnightByLocation)**: Возвращает время полуночи для указанного часового пояса.
- **[MidnightByTimeZone](#MidnightByTimeZone)**: Возвращает время полуночи для указанного часового пояса.

#### Midnight

Возвращает время, соответствующее полуночи для текущей даты в локальном часовом поясе.

**Возвращаемое значение:**

- `time.Time` — значение времени, соответствующее полуночи.
- `error` — ошибка, если произошла проблема с вычислением времени (обычно не возникает).

##### Пример использования:

```go
midnight, err := time.Midnight()
if err != nil {
// Обработка ошибки
}
// midnight: 2024-09-20 00:00:00 +0000 UTC
```

#### MidnightByLocation

Возвращает время полуночи для указанного часового пояса.

**Параметры:**

- `loc` — указатель на структуру `time.Location`, представляющую часовой пояс.

**Возвращаемое значение:**

- `time.Time` — значение времени, соответствующее полуночи в указанном часовом поясе.
- `error` — ошибка, если произошла проблема с вычислением времени (обычно не возникает).

##### Пример использования:

```go
loc, err := time.LoadLocation("Europe/Moscow")
if err != nil {
    // Обработка ошибки
}

midnight, err := time.MidnightByLocation(loc)
if err != nil {
    // Обработка ошибки
}
// midnight: 2024-09-20 00:00:00 +0300 MSK
```

#### MidnightByTimeZone

Возвращает время полуночи для указанного часового пояса.

**Параметры:**

- `timeZone` — строка, представляющая название часового пояса (например, "Europe/Moscow").

**Возвращаемое значение:**

- `time.Time` — значение времени, соответствующее полуночи в указанном часовом поясе.
- `error` — ошибка, если произошла проблема с загрузкой часового пояса (например, если указанный часовой пояс не
  существует).

##### Пример использования:

```go
midnight, err := time.MidnightByTimeZone("Europe/Moscow")
if err != nil {
    // Обработка ошибки
}
// midnight: 2024-09-20 00:00:00 +0300 MSK
```

